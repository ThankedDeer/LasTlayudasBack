// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: user.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    firstname,
    lastname,
    password,
    email
) VALUES (
    $1,$2,$3,$4
) RETURNING user_id, firstname, lastname, password, email, password_changed_at, created_at
`

type CreateUserParams struct {
	Firstname string `json:"firstname"`
	Lastname  string `json:"lastname"`
	Password  string `json:"password"`
	Email     string `json:"email"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (Users, error) {
	row := q.queryRow(ctx, q.createUserStmt, createUser,
		arg.Firstname,
		arg.Lastname,
		arg.Password,
		arg.Email,
	)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Password,
		&i.Email,
		&i.PasswordChangedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUserRole = `-- name: CreateUserRole :one
INSERT INTO user_roles (
    user_id,
    role_id,
    assigned_at
) VALUES (
    $1, $2, DEFAULT
) RETURNING user_id, role_id, assigned_at
`

type CreateUserRoleParams struct {
	UserID int32 `json:"user_id"`
	RoleID int32 `json:"role_id"`
}

func (q *Queries) CreateUserRole(ctx context.Context, arg CreateUserRoleParams) (UserRoles, error) {
	row := q.queryRow(ctx, q.createUserRoleStmt, createUserRole, arg.UserID, arg.RoleID)
	var i UserRoles
	err := row.Scan(&i.UserID, &i.RoleID, &i.AssignedAt)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID int32) error {
	_, err := q.exec(ctx, q.deleteUserStmt, deleteUser, userID)
	return err
}

const getUser = `-- name: GetUser :one
SELECT user_id, firstname, lastname, password, email, password_changed_at, created_at FROM users
WHERE email =$1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, email string) (Users, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, email)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Password,
		&i.Email,
		&i.PasswordChangedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserForUpdate = `-- name: GetUserForUpdate :one
SELECT user_id, firstname, lastname, password, email, password_changed_at, created_at FROM users
WHERE user_id =$1
FOR UPDATE
`

func (q *Queries) GetUserForUpdate(ctx context.Context, userID int32) (Users, error) {
	row := q.queryRow(ctx, q.getUserForUpdateStmt, getUserForUpdate, userID)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Password,
		&i.Email,
		&i.PasswordChangedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT user_id, firstname, lastname, password, email, password_changed_at, created_at FROM users
ORDER BY user_id
`

func (q *Queries) GetUsers(ctx context.Context) ([]Users, error) {
	rows, err := q.query(ctx, q.getUsersStmt, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Users
	for rows.Next() {
		var i Users
		if err := rows.Scan(
			&i.UserID,
			&i.Firstname,
			&i.Lastname,
			&i.Password,
			&i.Email,
			&i.PasswordChangedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithRoles = `-- name: GetUsersWithRoles :many
SELECT 
    u.user_id,
    u.firstname,
    u.lastname,
    u.password,
    u.email,
    r.role_id,
    r.name AS role_name,
    r.description AS role_description
FROM 
    users u
INNER JOIN 
    user_roles ur ON u.user_id = ur.user_id
INNER JOIN 
    roles r ON ur.role_id = r.role_id
ORDER BY 
    u.user_id
`

type GetUsersWithRolesRow struct {
	UserID          int32          `json:"user_id"`
	Firstname       string         `json:"firstname"`
	Lastname        string         `json:"lastname"`
	Password        string         `json:"password"`
	Email           string         `json:"email"`
	RoleID          int32          `json:"role_id"`
	RoleName        string         `json:"role_name"`
	RoleDescription sql.NullString `json:"role_description"`
}

func (q *Queries) GetUsersWithRoles(ctx context.Context) ([]GetUsersWithRolesRow, error) {
	rows, err := q.query(ctx, q.getUsersWithRolesStmt, getUsersWithRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersWithRolesRow
	for rows.Next() {
		var i GetUsersWithRolesRow
		if err := rows.Scan(
			&i.UserID,
			&i.Firstname,
			&i.Lastname,
			&i.Password,
			&i.Email,
			&i.RoleID,
			&i.RoleName,
			&i.RoleDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatPassword = `-- name: UpdatPassword :one
UPDATE users SET password = $2
WHERE email = $1
RETURNING user_id, firstname, lastname, password, email, password_changed_at, created_at
`

type UpdatPasswordParams struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

func (q *Queries) UpdatPassword(ctx context.Context, arg UpdatPasswordParams) (Users, error) {
	row := q.queryRow(ctx, q.updatPasswordStmt, updatPassword, arg.Email, arg.Password)
	var i Users
	err := row.Scan(
		&i.UserID,
		&i.Firstname,
		&i.Lastname,
		&i.Password,
		&i.Email,
		&i.PasswordChangedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updatUser = `-- name: UpdatUser :exec
UPDATE users SET 
firstname = $2,
lastname = $3,
password = $4,
email = $5
WHERE user_id = $1
RETURNING user_id, firstname, lastname, password, email, password_changed_at, created_at
`

type UpdatUserParams struct {
	UserID    int32  `json:"user_id"`
	Firstname string `json:"firstname"`
	Lastname  string `json:"lastname"`
	Password  string `json:"password"`
	Email     string `json:"email"`
}

func (q *Queries) UpdatUser(ctx context.Context, arg UpdatUserParams) error {
	_, err := q.exec(ctx, q.updatUserStmt, updatUser,
		arg.UserID,
		arg.Firstname,
		arg.Lastname,
		arg.Password,
		arg.Email,
	)
	return err
}
